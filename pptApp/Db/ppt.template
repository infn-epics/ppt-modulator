# EPICS Database for PPT Modulator - StreamDevice Binary Decoding
# Device support: stream
# Protocol file: ppt.proto
# 
# Strategy: Master record reads 86 bytes once per second, then FLNK chain
# triggers all other records to extract their values from StreamDevice's cache.
# This ensures atomic updates and only ONE TCP read per scan cycle.

# ============================================================================
# MASTER RECORD - Triggers device read and FLNK chain
# ============================================================================
# record(waveform, "$(P)RawData") {
#     field(DESC, "Raw Binary Data - 86 bytes")
#     field(DTYP, "stream")
#     field(INP,  "@ppt.proto readAllData $(PORT)")
#     field(SCAN, "1 second")
#     field(NELM, "86")
#     field(FTVL, "UCHAR")
#     field(PINI, "YES")
#     field(FLNK, "$(P)HeaterVoltage1")
# }

# ============================================================================
# VOLTAGE READINGS
# ============================================================================

# Heater Voltage 1 (bytes 0-1, WORD0)
record(ai, "$(P)HeaterVoltage1") {
    field(DESC, "Heater Voltage 1")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readHeaterVoltage1 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(LINR, "LINEAR")
    field(ESLO, "1")
    field(EOFF, "0")
    field(SCAN, "1 second")

    field(FLNK, "$(P)HeaterVoltage2")
}

# Heater Voltage 2 (bytes 28-29, WORD14)
record(ai, "$(P)HeaterVoltage2") {
    field(DESC, "Heater Voltage 2")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readHeaterVoltage2 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)ReservoirVoltage")
}

# Reservoir Voltage (bytes 4-5, WORD2)
record(ai, "$(P)ReservoirVoltage") {
    field(DESC, "Reservoir Voltage")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readReservoirVoltage $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)KlystronVoltage")
}

# Klystron Voltage (bytes 64-65, WORD32)
record(ai, "$(P)KlystronVoltage") {
    field(DESC, "Klystron Voltage")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readKlystronVoltage $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)MagnetVoltageCoil1")
}

# Magnet Voltage Coil 1 (bytes 72-73, WORD36)
record(ai, "$(P)MagnetVoltageCoil1") {
    field(DESC, "Magnet Voltage Coil 1")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readMagnetVoltageCoil1 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)MagnetVoltageCoil2")
}

# Magnet Voltage Coil 2 (bytes 80-81, WORD40)
record(ai, "$(P)MagnetVoltageCoil2") {
    field(DESC, "Magnet Voltage Coil 2")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readMagnetVoltageCoil2 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "V")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)TotalCurrent")
}

# ============================================================================
# CURRENT READINGS
# ============================================================================

# Total Current (bytes 8-9, WORD4)
record(ai, "$(P)TotalCurrent") {
    field(DESC, "Total Current")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readTotalCurrent $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "A")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)HeaterCurrent")
}

# Heater Current (bytes 32-33, WORD16)
record(ai, "$(P)HeaterCurrent") {
    field(DESC, "Heater Current")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readHeaterCurrent $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "A")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)KlystronCurrent")
}

# Klystron Current (bytes 68-69, WORD34)
record(ai, "$(P)KlystronCurrent") {
    field(DESC, "Klystron Current")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readKlystronCurrent $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "A")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)MagnetCurrentCoil1")
}

# Magnet Current Coil 1 (bytes 76-77, WORD38)
record(ai, "$(P)MagnetCurrentCoil1") {
    field(DESC, "Magnet Current Coil 1")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readMagnetCurrentCoil1 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "A")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)MagnetCurrentCoil2")
}

# Magnet Current Coil 2 (bytes 84-85, WORD42)
record(ai, "$(P)MagnetCurrentCoil2") {
    field(DESC, "Magnet Current Coil 2")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readMagnetCurrentCoil2 $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "A")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)BodyWaterInTemp")
}

# ============================================================================
# TEMPERATURE READINGS
# ============================================================================

# Body Water Input Temperature (bytes 36-37, WORD18)
record(ai, "$(P)BodyWaterInTemp") {
    field(DESC, "Body Water Input Temp")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readBodyWaterInTemp $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "C")
    field(PREC, "1")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)BodyWaterOutTemp")
}

# Body Water Output Temperature (bytes 40-41, WORD20)
record(ai, "$(P)BodyWaterOutTemp") {
    field(DESC, "Body Water Output Temp")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readBodyWaterOutTemp $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "C")
    field(PREC, "1")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)BodyWaterFlow")
}

# ============================================================================
# FLOW READINGS
# ============================================================================

# Body Water Flow (bytes 44-45, WORD22)
record(ai, "$(P)BodyWaterFlow") {
    field(DESC, "Body Water Flow")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readBodyWaterFlow $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "L/min")
    field(PREC, "2")
    field(ESLO, "1")
    field(EOFF, "0")
    field(FLNK, "$(P)TimerPreheatMin")
}

# ============================================================================
# TIMER READINGS
# ============================================================================

# Timer Preheating Minutes (bytes 12-13, WORD6)
record(longin, "$(P)TimerPreheatMin") {
    field(DESC, "Timer Preheating Minutes")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readTimerPreheatMin $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "min")
    field(FLNK, "$(P)TimerPreheatSec")
}

# Timer Preheating Seconds (bytes 16-17, WORD8)
record(longin, "$(P)TimerPreheatSec") {
    field(DESC, "Timer Preheating Seconds")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readTimerPreheatSec $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "sec")
    field(FLNK, "$(P)TimerPreheat100Min")
}

# Timer Preheating 100% Minutes (bytes 48-49, WORD24)
record(longin, "$(P)TimerPreheat100Min") {
    field(DESC, "Timer Preheat 100% Min")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readTimerPreheat100Min $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "min")
    field(FLNK, "$(P)TimerPreheat100Sec")
}

# Timer Preheating 100% Seconds (bytes 52-53, WORD26)
record(longin, "$(P)TimerPreheat100Sec") {
    field(DESC, "Timer Preheat 100% Sec")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readTimerPreheat100Sec $(PORT)")
    field(SCAN, "Passive")
    field(EGU,  "sec")
    field(FLNK, "$(P)InterlockMsg1")
}

# ============================================================================
# STATUS AND INTERLOCK MESSAGES
# ============================================================================

# Interlock Messages 1 (bytes 20-21, WORD10)
record(mbbi, "$(P)InterlockMsg1") {
    field(DESC, "Interlock Messages 1")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readInterlockMsg1 $(PORT)")
    field(SCAN, "Passive")
    field(NOBT, "16")
    field(SHFT, "0")
    field(FLNK, "$(P)InterlockMsg2")
}

# Interlock Messages 2 (bytes 56-57, WORD28)
record(mbbi, "$(P)InterlockMsg2") {
    field(DESC, "Interlock Messages 2")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readInterlockMsg2 $(PORT)")
    field(SCAN, "Passive")
    field(NOBT, "16")
    field(SHFT, "0")
    field(FLNK, "$(P)StatusMsg1")
}

# Status Messages 1 (bytes 24-25, WORD12)
record(mbbi, "$(P)StatusMsg1") {
    field(DESC, "Status Messages 1")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readStatusMsg1 $(PORT)")
    field(SCAN, "Passive")
    field(NOBT, "16")
    field(SHFT, "0")
    field(FLNK, "$(P)StatusMsg2")
}

# Status Messages 2 (bytes 60-61, WORD30)
record(mbbi, "$(P)StatusMsg2") {
    field(DESC, "Status Messages 2")
    field(DTYP, "stream")
    field(INP,  "@ppt.proto readStatusMsg2 $(PORT)")
    field(SCAN, "Passive")
    field(NOBT, "16")
    field(SHFT, "0")
}

# ============================================================================
# NOTES:
# ============================================================================
# 1. Each record uses StreamDevice to read and decode binary data directly
# 2. Protocol uses %(offset)<H format to extract 16-bit little-endian words
# 3. FLNK CHAIN ARCHITECTURE:
#    - Master record RawData scans at "1 second" and reads all 86 bytes
#    - This triggers a chain of 22 passive records via FLNK fields
#    - Chain order: RawData → Voltages(6) → Currents(5) → Temps(2) → Flow(1) → Timers(4) → Interlocks(2) → Status(2)
#    - All passive records read from StreamDevice's cached data (single TCP read)
#    - Ensures atomic updates: all PVs update together from same device snapshot
# 4. No calc records, no subArray records needed - clean and simple
# 5. All values automatically in EPICS native format (unsigned 16-bit -> double)
# 6. ESLO/EOFF fields allow scaling if device counts != engineering units
# ============================================================================
